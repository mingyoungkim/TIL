# 캐싱의 개념과 적용

## 알고 넘어가야 할 것

- 폰 노이만 구조
- 캐싱 -> 지역성 (공간 지역성, 시간 지역성)
- 안드로이드 이미지 해시 -> LRU
- HTTP 메소드는 GET 을 캐싱할 수 있다.
- LRU

## 좋은 AP

- 높은 신뢰성
- 보안
- 처리 속도/성능캐싱은 처리속도 성능과 상당히 연관이 있다.
- 편리한 UX

## 캐시

- 데이터나 값을 미리 복사해 놓는 임시 장소
- 원본 데이터를 접근하는 시간이 캐시의 접근 시간에 비해 오래 걸리는 경우
- 복잡한 수식을 재연산하는 시간을 절약하고 싶은 경우
- 캐시에 데이터를 미리 복사해 놓으면 계산, 접근 시간 없이 빠른 속도로 데이터에 접근 가능

## 책상에 어떤 책을 쌓아두지

- 아마도 바로 옆에 꽂혀있는
- 참고한지 오래 된 책은 치우기 (LRU?)
- 공간 지역성
- 시간 지역성

## 고전은 중요하다

애니악 -> 폰 노이만 구조 

- 폰 노이만 구조: 범용 컴퓨터의 구조기존 하드웨어 쓰는 명령에 세트를 메모리를 이용하여 버스를 통해 처리를 하자.병목 현상이 있는 곳 => 공간 지역서, 시간 지역성을 갖는 무엇인가를 놓자 (캐시 메모리)

## 생활 캐싱

- 요청이 있을 때 마다, 검색해서 찾는게 아니라. 미리 받아두고 저장을 해서 사용자에게 보여준다.
- 하지만 데이터가 바뀔 경우, 이러한 것들을 알려주는 것이 필요하다.
- 실시간 버스 현황APWAS -> 실시간 버스 현황AP

## IO 속도

- CPU
- 메모리
- 파일
- 네트워크

## 캐싱 적합 대상

- Write가 빈번하고 READ 는 거의 없는 경우
- READ가 Write는 거의 없는 경우수정이 없는 경우가 제일 적합하다.

------

## 바람직한 철학

- 가능한 많은 데이터를 캐싱하면 성능 향상
- 메모리는 매우 중요한 자원 -> 선별적인 캐싱 정책

------

캐싱  = 메모리 I/O

## TTL

- 보통 캐싱된 데이터에는 만료시간 및 갱신 주기가 존재함
- 데이터 sync 는 너무나도 중요

## 캐싱 적용기

- 메뉴 목록을 하드 코딩하지는 않는 것
- 메뉴 데이터는 DB 에 존재한다고 가정
- 사용자 요청이 많아질수록 DB 조회 많아짐

ORM 이나 래퍼에서 자체 캐싱이 있지만, 직접적으로 구현이 필요할 때가 있다.

------

## 직접 구현

- 메모리에 특정 객체를 생성한 후 캐싱하고자 하는 데이터를 저장
- 단 해당 프로세스에서 유일한 저장 장소가 되도록 잘 선언해서 사용

Java

1 2

```
List menuList = new ArrayList(); menuList = selectMenuListFromDB();
```

- 단일 머신에서는 문제가 없는데
- 실서버는 Cluster를 고려를 해야한다.원본 데이터가 변형이 될때, 머신에서 변경을 해주어야 하는데. 다른 것들은?내부적으로 옵저빙을 하든해서 변경시 업데이트가 필요하다.

## EHCache

- 로컬 캐시 라이브러리
- WAS n대 클러스터링 되어 있다면 동기화 이슈 발행
- WAS 간 내부 통신
- EHCache 가 RMI 클러스터링 지원

## 캐싱 적용기

- DB 방송 편성 데이터 상품 정보 관리
- 별도의 서버/솔루션 설치는 불가한 상황
- 성능 향상을 위해 메모리 캐싱 정책 고려

------

## REDIS

- NOSQL & Cache 솔루션, 메모리 기반으로 구성
- in-memory DB
- 데이터베이스로 사용될 수 있으며 Cache로도 사용할 수 있음.
- 하지만 역시는 오류는 있을 수 있다.

## 적용

- Cache의 기본적인 개념 파악
- 웹 AP 작성 코드에 DB 연동 조회 결과값을 특정 객체에 저장
- 로컬 캐시 적용기
- in-memory DB 솔루션 Redis 경험해보기
- 백엔드에서만 국한되는 문제는 아니다.