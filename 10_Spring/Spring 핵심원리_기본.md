# 스프링 프레임워크
> 핵심 `객체 지향` 애플리케이션을 만들수 있도록 지원
 ```text
   - 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타
   - 웹 기술: 스프링 MVC, 스프링 WebFlux
   - 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원
   - 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
   - 테스트: 스프링 기반 테스트 지원
   - 언어: 코틀린, 그루비핵심기술 : 스프링 
 ```
 - 객체지향의 핵심 : 다형성
 - 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.
 - 제어의 역전(IoC), 의존관계 주입(DI)로 스프링이 객체지향설계를 지원

 ## SOLID (좋은 객체 지향 설계의 5가지 원칙)
   1. SRP 단일책임원칙 (single responsibility principle)
     - 한 클래스는 하나의 책임만 가져야 한다. 
     - 문맥과 상황에 따라 다르다.
     - 중요한 기준은 `변경`. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것 
       예) UI 변경, 객체의 생성과 사용을 분리
   2. OCP 개방-폐쇄 원칙 (Open/closed principle)
     - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다. (다형성 활용)
     - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
   3. LSP 리스코프 치환 원칙 (Liskov substitution principle)
     - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다
     - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위 한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
       예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리 더라도 앞으로 가야함
   4. ISP 인터페이스 분리 원칙 (Interface segregation principle)
     - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다 
       예) 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
     - 다른 클라이언트에 영향을 주지 않음 인터페이스가 명확해지고, 대체 가능성이 높아진다.
   5. DIP 의존관계 역전 원칙 (Dependency inversion principle)
     - 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 의존성 주입은 이 원칙 을 따르는 방법 중 하나다.
       즉, 클라이언트가 interface만 바라봐야지, 구현체를 바라보고 알면 안됨

 ## 스프링 부트
 > 스프링을 편리하게 사용할 수 있도록 지원
   - Tomcat같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
   - starter 종속성으로 쉬운 빌드 구성
   - 스프링과 3th parth(외부) 라이브러리 자동 구성

 ## AppConfig
 > 애플리케이션 전체를 설정하고 구성한다.
 ![Spring_생성자](Spring.assets/spring_DIP.png)
   - 애플리케이션의 실제 동작에 필요한 구현 객체를 생성
   - 객체의 생성과 연결 담당
   - So, 관심사 분리 완료 (객체를 생성하는 역할 : config / 실행하는 역할 : impl)
   
    ### DI (Dependency Injection)
     > 의존성 주입 (의존성 관계) : 애플리케이션 `실행 시점(런타임)`에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것
     - 클라이언트인 ServiceImpl 입장에서, 의존관계를 마치 외부에서 주입해주는 것과 같음
     - 의존관계
       1. 정적인 클래스 의존 관계
         - 클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단 
         - 애플리케이션을 실행하지 않아도 소스코드만 보고도 알 수 있음
       2. 동적인 객체(인스턴스) 의존 관계
         - 실행 시점에 결정됨
     - 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경 가능
     - 정적인 클래스 의존관계를 변경하지 않고(== 애플리케이션 코드를 손대지 않고), 동적인 객체 인스턴스 의존관계를 쉽게 변경

    ### IoC (Inversion of Contol)
    > 제어의 역전 : 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것
     - 프레임워크가 Service나 코드를 자동으로 호출하는 흐름
     - AppConfig가 등장한 이후에 구현 객체는 자신의 로직을 실행하는 역할만 담당. 
     - 프로그램의 제어 흐름은 이제 AppConfig가 담당
 
    ✍️ 프레임워크 vs 라이브러리
      - 프레임워크는 작성한 코드를 제어하고, 대신 실행 (JUnit)
      - 반면에 작성한 코드가 직접 제어의 흐름을 담당하면 라이브러리다.

    ### IoC 컨테이너, DI 컨테이너
    > IoC를 해주는 컨테이너, DI를 해주는 컨테이너
     - AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것
     - 어샘블러, 오브젝트 팩토리 라고도 부름

 ## Spring Container
  > `ApplicationContext` : 스프링 컨테이너 (인터페이스)
   - 스프링 컨테이너는 `@Configuration` 이 붙은 `AppConfig` 를 설정(구성) 정보로 사용
   - `@Bean` 이 라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록 : `스프링빈`
  
  ![스프링Container1](Spring.assets/springContaier_1.png.png)
  ![스프링Container2](Spring.assets/springContainer_2.png)
  ```text
   1. new AnnotationConfigApplicationContext(AppConfig.class) 으로 AppConfig의 정보를 준다.
   2. 스프링 컨테이너가 만들어짐
   3. 스프링 컨테이너 안, 스프링 빈 저장소(key: 빈 이름, value: 빈 객체) 에 파라미터로 넘어온 해당 구성정보를 사용해서 스프링빈 등록
     (빈 이름은 항상 다른 이름을 부여)
   4. 스프링 컨테이너는 설정 정보를 참고해서 의존관계를 주입(DI)
  ```

 ## 스프링 빈
   - 빈 등록시, 동일한 타입이 둘 이상이면 오류 발생 => 빈 이름 등록해주면 됨

    ### 빈 등록 방법 (크게 두가지)
     1. 직접 스프링 빈 등록
      - xml 에 직접 bean 을 스프링 컨테이너에 등록
     2. Factory Method를 사용해서 등록
      - AppConfig 라는 facoryMethod 를 java code 로 등록

    ### 상속관계
     - 부모타입으로 조회하면 자식 타입도 같이 조회됨
     - 그래서 모든 자바 객체의 최고 부모인 `Object` 타입으로 조회하면, 모든 스프링 빈을 조회
     - java 는 기본적으로 최상위 부모는 Object 임

    ### Bean Factory
     - 스프링 컨테이너의 최상위 인터페이스
     - 스프링 빈을 관리하고 조회하는 역할을 담당 (getBena() 등 제공)
     ![스프링빈](Spring.assets/spring_Bean.png)

    ### ApplicationContext
     - BeanFactory 기능을 모두 상속받아서 제공
     - 애플리케이션을 개발할 때는 빈을 관리하고 조회하는 기능은 물론이고, 수 많은 부가기능이 필요
     - BeanFactory나 ApplicationContext를 스프링 컨테이너라 한다.
     - BeanFactory를 직접 사용할 일은 거의 없고, 부가기능이 포함된 ApplicationContext를 사용
     - ApplicationContext가 제공하는 부가 기능
       - 메시지소스를 활용한 국제화 기능 : 예를 들어서 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력
       - 환경변수 : 로컬, 개발, 운영등을 구분해서 처리
       - 애플리케이션 이벤트 : 이벤트를 발행하고 구독하는 모델을 편리하게 지원
       - 편리한 리소스 조회 : 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회
     ![ApplicationContext](Spring.assets/spring_ApplicationContext.png)

    ✍️ 스프링컨테이너의 다양한 설정형식 지원
    ![설정형식](Spring.assets/spring_setting.png)

    ### BeanDefinition
    > 스프링 빈 설정 메타정보 (인터페이스)
     - 빈 정보에 대한 것을 추상화 시킴
     - 역할과 구현을 개념적으로 나눈 것
     - 스프렝 컨테이너는 다양한 설정정보를 지원하는데(xml, java Code), 이는 BeanDefinition만 알면됨.
       (즉, 스프링 컨테이너는 BeanDefinition에만 의존)
     - `@Bean` , `<bean>` 당 각각 하나씩 메타 정보가 생성
     - 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성
    ![BeanDefinition](Spring.assets/spring_BeanDefinition.png)
    ![Detail](Spring.assets/beanDefinition_detail.png)

    ### BeanDefinition 정보
     - BeanClassName: 생성할 빈의 클래스 명(자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음) factoryBeanName: 팩토리 역할의 빈을 사용할 경우 이름, 예) appConfig
     - factoryMethodName: 빈을 생성할 팩토리 메서드 지정, 예) memberService
     - Scope: 싱글톤(기본값)
     - lazyInit: 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라, 실제 빈을 사용할 때 까지 최대한 생성을 지연 처리 하는지 여부
     - InitMethodName: 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명 DestroyMethodName: 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명
     - Constructor arguments, Properties: 의존관계 주입에서 사용한다. (자바 설정 처럼 팩토리 역할의 빈을 사용 하면 없음)

 ## 싱클톤 컨테이너
   - 스프링 없는 순수한 DI 컨테이너인 AppConfig는 요청을 할 때 마다 객체를 새로 생성
   - 대부분의 스프링 애플리케이션은 웹 애플리케이션, 웹 애플리케이션은 보통 여러 고객이 동시에 요청으로 심한 메모리 낭비
   - 해결방안 : 해당 객체가 딱 1개만 생성되고, 공유하도록 설계 👉 싱글톤 패턴

    ### 싱글톤 패턴
    > 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
     - private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 방지
     - 싱글톤 패턴 생성
       1. static 영역에 객체 instance를 미리 하나 생성
       2. 이 객체 인스턴스가 필요하면 오직 `getInstance()` 메서드를 통해서만 조회 가능. 이 메서드를 호출하면 항상 같은 인스턴스를 반환
       3. 딱 1개의 객체 인스턴스만 존재해야 하므로, 생성자를 private으로 막아서 혹시라도 외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 방지.
     - 싱글톤 패턴을 적용하면 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율 적으로 사용
     - 문제점
       - 싱글톤 패턴을 구현하는 코드 자체가 많이 들어감
       - 의존관계상 클라이언트가 구체 클래스에 의존 👉 DIP를 위반. 즉, 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높음
       - 테스트하기 어렵고 내부 속성을 변경하거나 초기화 하기 어려움
       - private 생성자로 자식 클래스를 만들기 어렵다. 즉, 결론적으로 유연성이 떨어진다.
       - 안티패턴으로 불리기도 한다.

     ‼️ 스프링 컨테이너는, 기본적으로 객체를 싱글톤으로 만들어서 관리해줌 👉 싱글톤 컨테이너

    ### 스프링컨테이너의 싱글톤 역할
    > 스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리
     - 싱글톤 레지스트리 : 싱글톤 객체를 생성하고 관리하는 기능

    ### 싱글톤 방식의 주의점
     - 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.
     - `무상태`(stateless)로 설계!
       - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
       - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!
       - 가급적 읽기만 가능해야 한다.
       - 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용

 ## @Configuration

  

    



    