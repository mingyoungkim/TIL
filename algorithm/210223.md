# Algorithm

## 02월 23일

### 01. 재귀호출

> 정의

- 자기 자신을 호출하여 순환 수행
- 일반적인 호출방식보다 프로그램 크기를 줄이고 간단하게 작성 가능



`피보나치 수 구하는 재귀함수`

```python
# 0과 1로 시작하고 이전의 두 수 합을 다음 항으로 하는 수열

def fibo(a):
    # 
    arr[a] += 1
    # a 가 2보다 작으면 0, 1 일 것이므로
    # 그대로 출력
    if a < 2:
        return a
    # 아니면, 그 전의 수와 전전 수를 더해서 출력
    else:
        return fibo(a-1) + fibo(a-2)

# 호출 회수
arr = [0] * 25

print(fibo(22))
print(arr)
```



---------------------------------------



### 02. Memoization

> 정의

- 재귀함수를 이용한 피보나치 함수는 엄청난 중복 호출이 발생😖

- 이 문제를 해결하기 위해 실행속도를 빠르게 하는 기술

  => 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 함👍

  ```python
  # fibo(n)의 값을 계산하자마자 저장하자.
  
  ---------------------------------------
  
  # 리스트를 내가 원하는 크기만큼 만들고
  # 그 값을 찍자
  
  # 길이 컨트롤이 필요
  
  ```



---------------------------------------



### 03. DP (Dynamic Programming)

> 정의

- 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘
- 입력 크기가 작은 부분 문제들을 모두 해결 후,
- 큰 크기의 부분문제들을 해결하는 방식



`피보나치 수 DP적용 알고리즘`

```python

```



- 과정
  - 문제를 부분 문제로 분할
  - 그 후, 가장 작은 문제부터 해결
  
- 비선형구조인 그래프 구조의 모든 자료 검색

  => 비선형구조인 그래프 구조를 모든 자료를 빠짐없이 검색하는 것이 중요!



> 방법

- 깊이 우선 탐색  DFS (Depth First Search)
  - 정해진 시작방향에서 갈 수 있는데 까지 가고 
  - 돌아나와 최근의 갈림길로 돌아가 다른 방향으로 간다.
  - 그 곳도 막혔다면 돌아나와
  - 불렀던 곳으로 돌아나가면서 갈림길이 있다면 다른 방향으로 또 가는 방법

- 너비 우선 탐색 BFS (Breath First Search)
  - 경로를 발견한 순으로 탐색
  - 갈림길에 들어서기 전에, 최근의 갈림길에서
  - 먼저 발견했지만 안들어가본 길로 돌아감
  - 그 다음 다시 아까의 갈림길로 들어가서 밑의 갈림길 들어감



반복과 stack, 재귀

인접행렬을 이용해 그래프 표현