# Algorithm

## 02월 16일

### 01. 검색

> 정의

- 저장되어 있는 자료 중 원하는 항목 찾기
- 종류
  - 순차 검색
  - 이진 검색



> 순차 검색 (Sequential Search)

- 일렬로 되어 있는 자료를 순서대로 검색

- 가장 간단, 직관적

- 구현은 쉽지만 검색 대상 수가 많으면 수행시간이 매우 증가 => 비효율적

- 검색 과정

  - 정렬이 되어 있지 않은 경우
    - 순서대로 우리가 찾고 싶은 값과 같은 원소가 있는지 비교
    - 정렬이 되어있지 않기 때문에 끝까지 확인 필요
    - 평균 비교 횟수 = (n+1)/2
    - 시간복잡도 = O(n)

  - 정렬이 되어 있는 경우
    - 순서대로 원소 값 비교
    - 원소값보다 크면 검색종료 (오름차순 기준)
    - 정렬이 되어있으므로, 
    - 검색실패 반환시 평균비교 회수 반으로 줄어듦

```python
# 01. 정렬 안되어 있는 경우

arr = [4, 11, 3, 9, 6, 5, 30]

# 찾고자 하는 값
key = 2

for i in range(len(arr)):
    if key == arr[i]:
        print(i, "에 위치하고 있음")
        # 찾으면 멈추자
        break

# for else 구문
# 반복문 수행 중 break 걸리지 않으면 else 수행
# break 걸리면 끝남
else:
    print("못찾음")

---------------------------------------    
# 02. 정렬 되어있는 경우

arr = [4, 5, 6, 9, 11, 30]
key = 10

for i in range(len(arr)):
    if key == arr[i]:
        print(i, '에 위치')
        break
        
    # key값이 arr[i]의 값보다 커지면 그만 찾아라 (오름차순 정렬이므로)
    elif key < arr[i]:
        print('이제 그만')
        break
```



> 이진 검색 (Binary Search)

- 자료의 가운데 있는 요소와 비교
- 그 다음 검색 위치 결정하고 검색 계속 진행
- 빠르게 검색 수행 가능
- **조건 : 자료가 정렬된 상태여야함!!!**
  - 그 다음 검색 위치 결정할 때 
  - key값보다 중앙값이 크면 중앙값 기준 왼쪽만 검색
  - key값보다 중앙값이 작으면 중앙값 기준 오른쪽만 검색

```python
arr = [1, 2, 4, 7, 9, 11, 19]
key = 4


def binarySearch(a, b):
    s = 0 # start
    e = len(a) - 1 # end
    
    # 시작점이 끝점보다 작거나 크면
    while s <= e:
        
        # 중간값 찾기
        mid = (s + e) // 2
        # 중간값이 key면 검색성공
        if a[mid] == key:
            return '성공'
        
        # 중간값이 key보다 크면 왼쪽을 검색해야함
        elif a[mid] > key:
            # 끝값을 바꿔줘야함
            e = mid - 1
        # 중간값이 key보다 작으면 오른쪽을 검색해야함
        else:
            # 시작점을 바꿔줘야함
            s = mid + 1
            
    # 결국 못찾으면 실패
    return '실패'

my_arr = binarySearch(arr, key)
print(my_arr)
```



---------------------------------------



### 02. 셀렉션 알고리즘

> 정의

- 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
- 즉, 최대값/ 최소값/ 중간값 찾는 알고리즘



---------------------------------------



### 03. 선택 정렬

- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택해서 위치를 교환하는 방식
- 셀렉션 알고리즘을 전체 자료에 적용한 것
- 정렬 과정
  - 최소값을 찾기
  - 그 값을 리스트의 맨 앞에 위치한 값과 교환
  - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 다시 위의 과정 반복
- 시간 복잡도 = O(n^2)

```python
arr = [10, 15, 2, 19, 6, 28]

# 정렬할 범위 잡기
# 맨 마지막에 남은 애는 정렬안해도 되므로 -1
for i in range(len(arr) - 1):
    # 최소값이 들어있는 인덱스 (기준위치)
    minidx = i
    
    # 최소값이 든 인덱스 빼고 그 다음 값부터 찾아야함
    # 지금은 최소값을 찾는 중이니까 범위를 끝까지 잡아야함
    for j in range(i + 1, len(arr)):
        
        # 현재 minidx의 값이 j번째의 값보다 크면
        if arr[minidx] > arr[j]:
            # 최소값이 든 인덱스 갱신
            minidx = j
    
    arr[minidx], arr[i] = arr[i], arr[minidx]

print(arr)
```
